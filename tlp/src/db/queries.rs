/*!
`salsa` query groups and implementations

Most data types in this module are automatically generated by `salsa` macros.
*/

use std::sync::Arc;

use camino::{Utf8Path, Utf8PathBuf};

use crate::{
    db::ids::*,
    ir::lower::{
        def,
        loc::*,
        tree::{CrateTree, ModuleTree},
        LowerError,
    },
    syntax::ast::{self, ParseResult},
    utils::line_index::LineIndex,
};

#[salsa::query_group(SourceDB)]
pub trait Source: salsa::Database {
    #[salsa::input]
    fn input(&self, path: Utf8PathBuf) -> Arc<String>;

    fn line_index(&self, path: Utf8PathBuf) -> Arc<LineIndex>;
}

fn line_index(db: &dyn Source, name: Utf8PathBuf) -> Arc<LineIndex> {
    let input = db.input(name);
    Arc::new(LineIndex::new(&input))
}

#[salsa::query_group(ParseDB)]
pub trait Parse: Source {
    /// The parsed form of the request.
    fn parse(&self, path: Utf8PathBuf) -> Arc<ParseResult>;
}

fn parse(db: &dyn Parse, path: Utf8PathBuf) -> Arc<ParseResult> {
    let src = db.input(path);
    let res = ast::parse(&src);
    Arc::new(res)
}

/// Interner of locations
#[salsa::query_group(InternDB)]
pub trait Intern: salsa::Database {
    #[salsa::interned]
    fn intern_access(&self, access: AbsAccess) -> Access;
    #[salsa::interned]
    fn intern_proc(&self, def: def::DefProc) -> Proc;
    #[salsa::interned]
    fn intern_module_loc(&self, module: ModuleLoc) -> Module;
    #[salsa::interned]
    fn intern_crate_loc(&self, krate: CrateLoc) -> Crate;
}

#[salsa::query_group(LowerModuleDB)]
pub trait LowerModule: Parse + Intern {
    fn module_tree(&self, module: Module) -> Arc<ModuleLower>;
}

fn module_tree(db: &dyn LowerModule, module: Module) -> Arc<ModuleLower> {
    let module_loc = db.lookup_intern_module_loc(module);
    let module_path = module_loc.access().to_path_buf();

    let ast = db.parse(module_path.clone()).doc.clone();

    let krate = module_loc.krate().clone();
    let tree = ModuleTree::crate_root(krate, module);

    let mut lower = ModuleLower::new(tree);
    lower.lower(db, &module_path, ast);
    Arc::new(lower)
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleLower {
    pub errs: Vec<LowerError>,
    pub tree: ModuleTree,
}

impl ModuleLower {
    fn new(tree: ModuleTree) -> Self {
        Self {
            errs: Vec::new(),
            tree,
        }
    }

    fn lower(&mut self, db: &dyn LowerModule, module_path: &Utf8Path, ast: ast::data::Document) {
        self.lower_procs(db, module_path, ast.item_nodes());
    }

    fn lower_procs(
        &mut self,
        db: &dyn LowerModule,
        module_path: &Utf8Path,
        forms: impl Iterator<Item = ast::data::Form>,
    ) {
        for form in forms {
            if let Some(ast) = form.as_proc() {
                // TODO: validate name?
                let tk = ast.name_tk();
                let name = tk.text();
                let access_data = AbsAccess::new(module_path.join(name));
                let access = db.intern_access(access_data);

                if let Some(def_proc) = self.lower_proc(db, access, ast) {
                    self.tree.procs.push(def_proc);
                }
            }
        }
    }

    fn lower_proc(
        &mut self,
        db: &dyn LowerModule,
        access: Access,
        ast: ast::data::DefProc,
    ) -> Option<def::DefProc> {
        if self.tree.procs.iter().any(|p| p.access == access) {
            self.errs.push(LowerError::DupProc {
                access: db.lookup_intern_access(access),
                s: ast.name_tk().text().to_string(),
            });
            return None;
        }

        let proc = def::DefProc::new(ast, access);
        Some(proc)
    }
}

#[salsa::query_group(LowerCrateDB)]
pub trait LowerCrate: LowerModule {
    fn crate_tree(&self, krate: CrateLoc) -> CrateTree;
}

fn crate_tree(db: &dyn LowerCrate, krate: CrateLoc) -> CrateTree {
    todo!()
}
