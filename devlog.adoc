= toylisp devlog
:glsp: https://gamelisp.rs/[GameLisp]
:snowrl: https://github.com/toyboot4e/snowrl[SnowrL]
:cr: https://craftinginterpreters.com/contents.html[Crafting Interpreters]
:toy-scheme: https://github.com/toyboot4e/toy-scheme[toy-scheme]

:ra: https://github.com/rust-analyzer/rust-analyzer[rust-analyzer]
:rowan: https://github.com/rust-analyzer/rowan/[rowan]
:rowan-s: https://github.com/rust-analyzer/rowan/blob/master/examples/s_expressions.rs[s_expressions.rs]

== Background

I wanted to add scripting support for my game ({snowrl}) and {glsp} looked nice, but it didn't have `:named arg` syntax. Then I suddenly wanted to make my own Lisp: toylisp (`tlp`).

I did {cr} (part II: tree-walk interpreter) in years ago. I made an Emacs package in ELisp ({toy-scheme}), still I know little about Lisp. I'd have to struggle a lot.

== Devlog

=== Before knowing CST

I believed TopLisp would do this conversion: source string → AST → bytecode.

==== Lexer (tokenizer)

* Jun 9, 2021
+
I added a WIP lexer (tokenizer) which converts given string (`&str`) into a vector of tokens.
+
** The lexer handles non-streaming input/output or simplicity.
** The lexer handles UTF-8 string as bytes (as `&[u8]`, not as `Iterator<char>`) because we're only interested in ASCII characters while lexing.

* Jun 12, 2021
+
Nice resource from `rustc` dev guide: https://rustc-dev-guide.rust-lang.org/the-parser.html[Lexing and Parsing],

* Jun 17, 2021
+
I parsed `Vec<Token>` into a hierarchy of tokens (S-expressions represented as spans of tokens in the vector). I'm not sure if it's a good idea to stick with tokens..

==== Compiler and bytecode virtual machine

* Jun 17, 2021
+
I added a simple VM which can calculate arithmetics. It's stack-based as a VM in the book ({cr}).
+
I also added a compiler. Now `(/ (- 64.0 32.0) 2)` evaluates to `16.0`.

=== Follow `rust-analyzer`

I want my ideal lang to be statically typed, and the parser should be IDE-oriented. It would be a great if I can learn from {ra}.

==== CST

* Jun 21, 2021
+
Accoording to the doc, {ra} converts source file string into a lossless _(concrete) syntax tree_ with {rowan} footnote:[{rowan} was doing aggressive optimization: deduplication of subtree and use of thin pointers. I couldn't do better than that, so I decided to just use {rowan} instead of re-writing it.].
+
I didn't know the notion of CST. It's basically a tree representation of text (syntax), where each element footnote:[element = sub tree (node) or leaf (token)] is tagged with syntax _kind_ s. The good thing about CST is that each element is _homogeneous_ and _untyped_, so we can easily create CST for invalid source string in toylisp grammer.
+
Today I parsed simple arithmetics with {rowan}. To run toylisp again, I'd make CST → AST step.

* Jun 25, 2021
+
I added a WIP AST, which can't be run yet. I'll make an LSP server while developing `tlp`.
+
In context of {rowan}, an AST node is just a wrapper around a CST node; it's just a subtree of tokens with accessor methods.

== Syntax

* string
* quote
* docstring

== LSP

* completion
* go to definition
* show type and documentation
* rename item
