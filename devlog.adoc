= ToyLisp devlog
:glsp: https://gamelisp.rs/[GameLisp]
:snowrl: https://github.com/toyboot4e/snowrl[SnowrL]
:cr: https://craftinginterpreters.com/contents.html[Crafting Interpreters]
:toy-scheme: https://github.com/toyboot4e/toy-scheme[toy-scheme]

:ra: https://github.com/rust-analyzer/rust-analyzer[rust-analyzer]
:rowan: https://github.com/rust-analyzer/rowan/[rowan]
:rowan-s: https://github.com/rust-analyzer/rowan/blob/master/examples/s_expressions.rs[s_expressions.rs]

== Background

I wanted to add scripting support for my game ({snowrl}) and {glsp} looked nice, but it didn't have `:named arg` syntax. Then I suddenly wanted to make my own Lisp: ToyLisp (`tlp`).

I did {cr} (part II: tree-walk interpreter) in years ago. I made an Emacs package in ELisp ({toy-scheme}), still I know little about Lisp. I'd have to struggle a lot.

== Devlog

=== Before knowing CST

I believed TopLisp would do this conversion: source string → AST → bytecode.

==== Lexer (tokenizer)

* Jun 9, 2021
+
I added a WIP lexer (tokenizer) which converts given string (`&str`) into a vector of tokens.
+
** The lexer handles non-streaming input/output or simplicity.
** The lexer handles UTF-8 string as bytes (as `&[u8]`, not as `&[char]`) because we're only interested in ASCII characters while lexing.

* Jun 12, 2021
+
Nice resource from `rustc` dev guide: https://rustc-dev-guide.rust-lang.org/the-parser.html[Lexing and Parsing]

* Jun 17, 2021
+
I parsed `Vec<Token>` into a hierarchy of tokens (S-expressions represented as spans of tokens in the vector). I'm not sure if it's a good idea to stick with tokens, but it doesn't lose any span of source code, so I'm going with it (for now).

==== Compiler and bytecode virtual machine

* Jun 17, 2021
+
I added a simple VM which can calculate arithmetics. It's stack-based as one in the book ({cr}).
+
I also added a compiler. Now `(/ (- 64.0 32.0) 2)` evaluates to `16.0`.

=== Follow `rust-analyzer`

I want my ideal lang to be statically typed, and the parser should be IDE-oriented. It would be a great idea to learn from {ra}.

==== CST

* Jun 21, 2021
+
Accoording to the doc, {ra} converts source file string into a lossless _(concrete) syntax tree_ with {rowan} footnote:[{rowan} was doing aggressive optimization; it made use of deduplication of subtree. {rowan} even it used thin pointers to reduce the memory usage. I can't do better than that, so I decided to just use {rowan} without re-writing it.].
+
I didn't know the notion of CST. It's basically a tree representation of text, where each element footnote:[element = sub tree (node) or leaf (token)] is tagged with syntax _kind_ s. The good thing about CST is the each element is _homogeneous_ and _untyped_, so we can easily create CST for invalid source string in ToyLisp grammer.
+
Today I parsed simple arithmetics with `rowan`. To run ToyLisp again, I'd make CST → AST step.
